# üß™ Testes e Valida√ß√£o - Solview

## üéØ Vis√£o Geral

Este guia apresenta estrat√©gias completas para **testar e validar** a instrumenta√ß√£o Solview, desde desenvolvimento at√© produ√ß√£o.

---

## üî¨ Testes de Instrumenta√ß√£o

### ‚úÖ **Testes Unit√°rios**

#### **1. Testando Setup de Logging**

```python
# tests/test_solview_setup.py
import pytest
import structlog
from fastapi.testclient import TestClient
from solview import SolviewSettings, setup_logger

def test_logger_setup():
    """Testa se o logger est√° configurado corretamente"""
    settings = SolviewSettings(
        service_name="test-service",
        log_level="DEBUG"
    )
    
    # Setup
    setup_logger(settings)
    logger = structlog.get_logger(__name__)
    
    # Teste: Logger deve estar configurado
    assert logger is not None
    
    # Teste: Logger deve aceitar contexto estruturado
    logger.info("Test message", user_id=123, action="test")
    
    # TODO: Verificar se log foi emitido corretamente
    # Implementar captura de logs para valida√ß√£o

def test_logger_masking():
    """Testa masking de dados sens√≠veis"""
    from solview.security import EnhancedDataMasking as DataMasker, MaskingRule
    
    masker = DataMasker()
    
    # Dados de teste
    data = {
        "user_id": 123,
        "email": "user@example.com",
        "password": "secret123",
        "cpf": "123.456.789-00"
    }
    
    # Aplicar masking
    masked = masker.mask_dict(data)
    
    # Verifica√ß√µes
    assert masked["user_id"] == 123  # N√£o sens√≠vel
    assert "user@example.com" not in str(masked["email"])  # Mascarado
    assert masked["password"] == "***"  # Completamente mascarado
    assert "123.456.789-00" not in str(masked["cpf"])  # Mascarado
```

#### **2. Testando M√©tricas**

```python
# tests/test_metrics.py
import pytest
from prometheus_client import CollectorRegistry, Counter
from fastapi.testclient import TestClient
from solview.metrics import SolviewPrometheusMiddleware

def test_metrics_middleware():
    """Testa se middleware de m√©tricas funciona"""
    from main import app  # Sua aplica√ß√£o
    
    client = TestClient(app)
    
    # Fazer requisi√ß√µes
    response1 = client.get("/health")
    response2 = client.get("/health")
    response3 = client.get("/nonexistent", allow_redirects=False)
    
    # Verificar responses
    assert response1.status_code == 200
    assert response2.status_code == 200
    assert response3.status_code == 404
    
    # Verificar m√©tricas
    metrics_response = client.get("/metrics")
    assert metrics_response.status_code == 200
    
    metrics_text = metrics_response.text
    
    # Verificar se m√©tricas HTTP est√£o presentes
    assert "http_requests_total" in metrics_text
    assert "http_request_duration_seconds" in metrics_text
    assert "http_responses_total" in metrics_text
    
    # Verificar contadores espec√≠ficos
    assert 'method="GET"' in metrics_text
    assert 'status_code="200"' in metrics_text
    assert 'status_code="404"' in metrics_text

def test_custom_metrics():
    """Testa m√©tricas customizadas"""
    # Criar registry isolado para teste
    registry = CollectorRegistry()
    
    # M√©trica customizada
    custom_counter = Counter(
        'test_operations_total',
        'Test operations',
        ['operation_type'],
        registry=registry
    )
    
    # Incrementar
    custom_counter.labels(operation_type='create').inc()
    custom_counter.labels(operation_type='update').inc(2)
    
    # Coletar m√©tricas
    from prometheus_client import generate_latest
    metrics_output = generate_latest(registry).decode('utf-8')
    
    # Verificar
    assert 'test_operations_total{operation_type="create"} 1.0' in metrics_output
    assert 'test_operations_total{operation_type="update"} 2.0' in metrics_output
```

#### **3. Testando Tracing**

```python
# tests/test_tracing.py
import pytest
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import SimpleSpanProcessor
from opentelemetry.test.test_utils import TestSpanExporter
from fastapi.testclient import TestClient

def test_trace_setup():
    """Testa setup b√°sico de tracing"""
    from solview.tracing import setup_tracer
    from solview import SolviewSettings
    
    settings = SolviewSettings(service_name="test-service")
    
    # Setup com exporter de teste
    test_exporter = TestSpanExporter()
    tracer = setup_tracer(settings)
    
    # Criar span de teste
    with tracer.start_as_current_span("test_span") as span:
        span.set_attribute("test.key", "test.value")
        span.set_attribute("test.number", 42)
    
    # Verificar se span foi criado
    spans = test_exporter.get_finished_spans()
    assert len(spans) == 1
    
    span = spans[0]
    assert span.name == "test_span"
    assert span.attributes["test.key"] == "test.value"
    assert span.attributes["test.number"] == 42

def test_fastapi_instrumentation():
    """Testa instrumenta√ß√£o autom√°tica do FastAPI"""
    from main import app
    
    # Setup de teste com span exporter
    test_exporter = TestSpanExporter()
    
    client = TestClient(app)
    
    # Fazer requisi√ß√£o
    response = client.get("/health")
    assert response.status_code == 200
    
    # Verificar spans criados
    spans = test_exporter.get_finished_spans()
    
    # Deve ter pelo menos 1 span da requisi√ß√£o HTTP
    http_spans = [s for s in spans if s.name.startswith("GET")]
    assert len(http_spans) >= 1
    
    # Verificar attributes do span HTTP
    http_span = http_spans[0]
    assert http_span.attributes.get("http.method") == "GET"
    assert http_span.attributes.get("http.status_code") == 200
```

---

## üîç Testes de Integra√ß√£o

### ‚úÖ **Testes de Stack Completa**

#### **1. Teste de Conectividade**

```python
# tests/integration/test_observability_stack.py
import pytest
import asyncio
import aiohttp
from fastapi.testclient import TestClient

class TestObservabilityStack:
    """Testes de integra√ß√£o com stack completa"""
    
    @pytest.fixture(scope="class")
    def stack_urls(self):
        return {
            "app": "http://localhost:8000",
            "prometheus": "http://localhost:9090", 
            "grafana": "http://localhost:3000",
            "loki": "http://localhost:3100",
            "tempo": "http://localhost:3200"
        }
    
    def test_app_health(self, stack_urls):
        """Testa se aplica√ß√£o est√° saud√°vel"""
        import requests
        
        response = requests.get(f"{stack_urls['app']}/health")
        assert response.status_code == 200
        
        data = response.json()
        assert data["status"] == "healthy"
    
    def test_metrics_endpoint(self, stack_urls):
        """Testa endpoint de m√©tricas"""
        import requests
        
        response = requests.get(f"{stack_urls['app']}/metrics")
        assert response.status_code == 200
        
        # Verificar m√©tricas essenciais
        metrics_text = response.text
        assert "http_requests_total" in metrics_text
        assert "http_request_duration_seconds" in metrics_text
        assert "process_cpu_usage_percent" in metrics_text
    
    def test_prometheus_scraping(self, stack_urls):
        """Testa se Prometheus est√° coletando m√©tricas"""
        import requests
        import time
        
        # Fazer algumas requisi√ß√µes para gerar m√©tricas
        for _ in range(5):
            requests.get(f"{stack_urls['app']}/health")
        
        # Aguardar scraping (15s de intervalo padr√£o)
        time.sleep(20)
        
        # Verificar se Prometheus tem as m√©tricas
        query = "http_requests_total{job='solview-demo-app'}"
        response = requests.get(
            f"{stack_urls['prometheus']}/api/v1/query",
            params={"query": query}
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "success"
        assert len(data["data"]["result"]) > 0
    
    def test_trace_generation(self, stack_urls):
        """Testa se traces est√£o sendo gerados"""
        import requests
        import time
        
        # Fazer requisi√ß√£o para gerar trace
        requests.get(f"{stack_urls['app']}/health")
        
        # Aguardar processamento
        time.sleep(10)
        
        # Verificar se Tempo recebeu traces
        response = requests.get(f"{stack_urls['tempo']}/api/search")
        assert response.status_code == 200
        
        data = response.json()
        assert "traces" in data
    
    async def test_log_correlation(self, stack_urls):
        """Testa correla√ß√£o de logs com traces"""
        import json
        
        # Fazer requisi√ß√£o que gera logs
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{stack_urls['app']}/health") as response:
                trace_id = response.headers.get("traceparent", "").split("-")[1] if "traceparent" in response.headers else None
        
        if trace_id:
            # Verificar se logs cont√™m trace_id
            await asyncio.sleep(5)  # Aguardar processamento
            
            # Query Loki para logs com trace_id
            query = f'{{service_name="solview-demo-app"}} | json | trace_id="{trace_id}"'
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{stack_urls['loki']}/loki/api/v1/query",
                    params={"query": query}
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        # Verificar se encontrou logs correlacionados
                        assert "data" in data
```

#### **2. Teste de Performance**

```python
# tests/integration/test_performance.py
import pytest
import asyncio
import aiohttp
import time
import statistics

class TestPerformanceImpact:
    """Testa impacto de performance da instrumenta√ß√£o"""
    
    async def test_latency_overhead(self):
        """Mede overhead de lat√™ncia da instrumenta√ß√£o"""
        
        async def make_request(session, url):
            start = time.time()
            async with session.get(url) as response:
                await response.text()
            return time.time() - start
        
        url = "http://localhost:8000/health"
        requests_count = 100
        
        async with aiohttp.ClientSession() as session:
            # Warm up
            for _ in range(10):
                await make_request(session, url)
            
            # Medir lat√™ncias
            latencies = []
            for _ in range(requests_count):
                latency = await make_request(session, url)
                latencies.append(latency)
        
        # An√°lise estat√≠stica
        avg_latency = statistics.mean(latencies)
        p95_latency = statistics.quantiles(latencies, n=20)[18]  # 95th percentile
        
        # Assertions - instrumenta√ß√£o n√£o deve adicionar mais que 5ms
        assert avg_latency < 0.005  # 5ms
        assert p95_latency < 0.010  # 10ms
        
        print(f"Average latency: {avg_latency*1000:.2f}ms")
        print(f"P95 latency: {p95_latency*1000:.2f}ms")
    
    async def test_throughput_impact(self):
        """Mede impacto no throughput"""
        
        async def worker(session, url, results, duration):
            end_time = time.time() + duration
            count = 0
            
            while time.time() < end_time:
                async with session.get(url) as response:
                    if response.status == 200:
                        count += 1
            
            results.append(count)
        
        url = "http://localhost:8000/health"
        duration = 10  # 10 segundos
        workers = 5
        
        async with aiohttp.ClientSession() as session:
            results = []
            tasks = [
                worker(session, url, results, duration)
                for _ in range(workers)
            ]
            
            await asyncio.gather(*tasks)
        
        total_requests = sum(results)
        rps = total_requests / duration
        
        # Assertion - deve conseguir pelo menos 1000 RPS
        assert rps > 1000
        
        print(f"Throughput: {rps:.0f} RPS")
```

---

## üöÄ Testes de Carga

### ‚úÖ **Scripts de Load Testing**

#### **1. Teste B√°sico de Carga**

```python
# tests/load/basic_load_test.py
import asyncio
import aiohttp
import time
from dataclasses import dataclass
from typing import List

@dataclass
class LoadTestResult:
    total_requests: int
    successful_requests: int
    failed_requests: int
    avg_latency: float
    p95_latency: float
    p99_latency: float
    throughput: float
    error_rate: float

class LoadTester:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.results = []
    
    async def make_request(self, session: aiohttp.ClientSession, endpoint: str) -> dict:
        start_time = time.time()
        try:
            async with session.get(f"{self.base_url}{endpoint}") as response:
                await response.text()
                return {
                    "success": True,
                    "status_code": response.status,
                    "latency": time.time() - start_time,
                    "error": None
                }
        except Exception as e:
            return {
                "success": False,
                "status_code": 0,
                "latency": time.time() - start_time,
                "error": str(e)
            }
    
    async def run_load_test(
        self,
        endpoints: List[str],
        concurrent_users: int,
        duration_seconds: int
    ) -> LoadTestResult:
        """Executa teste de carga"""
        
        async def worker(session: aiohttp.ClientSession):
            worker_results = []
            end_time = time.time() + duration_seconds
            
            while time.time() < end_time:
                # Escolher endpoint aleatoriamente
                import random
                endpoint = random.choice(endpoints)
                
                result = await self.make_request(session, endpoint)
                worker_results.append(result)
                
                # Small delay to simulate real usage
                await asyncio.sleep(0.01)
            
            return worker_results
        
        # Executar workers concorrentes
        connector = aiohttp.TCPConnector(limit=concurrent_users * 2)
        async with aiohttp.ClientSession(connector=connector) as session:
            tasks = [worker(session) for _ in range(concurrent_users)]
            all_results = await asyncio.gather(*tasks)
        
        # Flatten results
        flat_results = [item for sublist in all_results for item in sublist]
        
        # Calcular estat√≠sticas
        return self._calculate_stats(flat_results)
    
    def _calculate_stats(self, results: List[dict]) -> LoadTestResult:
        total = len(results)
        successful = len([r for r in results if r["success"]])
        failed = total - successful
        
        latencies = [r["latency"] for r in results]
        latencies.sort()
        
        return LoadTestResult(
            total_requests=total,
            successful_requests=successful,
            failed_requests=failed,
            avg_latency=sum(latencies) / len(latencies),
            p95_latency=latencies[int(len(latencies) * 0.95)],
            p99_latency=latencies[int(len(latencies) * 0.99)],
            throughput=total / duration_seconds if duration_seconds > 0 else 0,
            error_rate=(failed / total) * 100 if total > 0 else 0
        )

# Uso do teste
async def main():
    tester = LoadTester("http://localhost:8000")
    
    endpoints = ["/health", "/metrics", "/"]
    
    print("üöÄ Iniciando teste de carga...")
    result = await tester.run_load_test(
        endpoints=endpoints,
        concurrent_users=50,
        duration_seconds=60
    )
    
    print(f"üìä Resultados:")
    print(f"  Total de requests: {result.total_requests}")
    print(f"  Sucessos: {result.successful_requests}")
    print(f"  Falhas: {result.failed_requests}")
    print(f"  Taxa de erro: {result.error_rate:.2f}%")
    print(f"  Throughput: {result.throughput:.0f} RPS")
    print(f"  Lat√™ncia m√©dia: {result.avg_latency*1000:.1f}ms")
    print(f"  Lat√™ncia P95: {result.p95_latency*1000:.1f}ms")
    print(f"  Lat√™ncia P99: {result.p99_latency*1000:.1f}ms")

if __name__ == "__main__":
    asyncio.run(main())
```

#### **2. Teste de Stress**

```python
# tests/load/stress_test.py
import asyncio
import aiohttp
from load.basic_load_test import LoadTester

async def stress_test():
    """Teste de stress progressivo"""
    tester = LoadTester("http://localhost:8000")
    endpoints = ["/health"]
    
    stress_levels = [10, 25, 50, 100, 200, 500]
    duration = 30  # 30 segundos por n√≠vel
    
    print("üî• Iniciando teste de stress progressivo...")
    
    for users in stress_levels:
        print(f"\nüìà Testando com {users} usu√°rios concorrentes...")
        
        result = await tester.run_load_test(
            endpoints=endpoints,
            concurrent_users=users,
            duration_seconds=duration
        )
        
        print(f"  Throughput: {result.throughput:.0f} RPS")
        print(f"  Error Rate: {result.error_rate:.2f}%")
        print(f"  P95 Latency: {result.p95_latency*1000:.1f}ms")
        
        # Crit√©rios de falha
        if result.error_rate > 5.0:
            print(f"‚ùå FALHA: Taxa de erro muito alta ({result.error_rate:.2f}%)")
            break
        
        if result.p95_latency > 1.0:
            print(f"‚ö†Ô∏è  ALERTA: Lat√™ncia alta ({result.p95_latency*1000:.1f}ms)")
        
        # Intervalo entre testes
        await asyncio.sleep(5)
    
    print("\nüèÅ Teste de stress conclu√≠do!")

if __name__ == "__main__":
    asyncio.run(stress_test())
```

---

## üìä Valida√ß√£o de Observabilidade

### ‚úÖ **Checklist de Valida√ß√£o**

```python
# tests/validation/observability_checklist.py
import requests
import json
import time
from typing import Dict, List, Tuple

class ObservabilityValidator:
    def __init__(self, base_url: str, prometheus_url: str, grafana_url: str):
        self.base_url = base_url
        self.prometheus_url = prometheus_url
        self.grafana_url = grafana_url
        self.results = {}
    
    def validate_all(self) -> Dict[str, bool]:
        """Executa todas as valida√ß√µes"""
        validators = [
            ("health_endpoint", self.validate_health_endpoint),
            ("metrics_endpoint", self.validate_metrics_endpoint),
            ("structured_logs", self.validate_structured_logs),
            ("trace_headers", self.validate_trace_headers),
            ("prometheus_scraping", self.validate_prometheus_scraping),
            ("metric_cardinality", self.validate_metric_cardinality),
            ("trace_sampling", self.validate_trace_sampling),
            ("grafana_dashboards", self.validate_grafana_dashboards),
        ]
        
        for name, validator in validators:
            try:
                self.results[name] = validator()
                status = "‚úÖ" if self.results[name] else "‚ùå"
                print(f"{status} {name}")
            except Exception as e:
                self.results[name] = False
                print(f"‚ùå {name}: {e}")
        
        return self.results
    
    def validate_health_endpoint(self) -> bool:
        """Valida endpoint de health"""
        response = requests.get(f"{self.base_url}/health")
        return response.status_code == 200
    
    def validate_metrics_endpoint(self) -> bool:
        """Valida endpoint de m√©tricas"""
        response = requests.get(f"{self.base_url}/metrics")
        
        if response.status_code != 200:
            return False
        
        required_metrics = [
            "http_requests_total",
            "http_request_duration_seconds",
            "http_responses_total"
        ]
        
        metrics_text = response.text
        return all(metric in metrics_text for metric in required_metrics)
    
    def validate_structured_logs(self) -> bool:
        """Valida se logs est√£o estruturados"""
        # Fazer requisi√ß√£o para gerar log
        response = requests.get(f"{self.base_url}/health")
        
        # Note: Em um teste real, voc√™ capturaria os logs
        # Para este exemplo, assumimos que est√° configurado
        return True
    
    def validate_trace_headers(self) -> bool:
        """Valida se headers de trace est√£o presentes"""
        response = requests.get(f"{self.base_url}/health")
        
        # Verificar se response cont√©m headers de tracing
        trace_headers = [
            "traceparent",
            "tracestate"
        ]
        
        return any(header in response.headers for header in trace_headers)
    
    def validate_prometheus_scraping(self) -> bool:
        """Valida se Prometheus est√° coletando m√©tricas"""
        # Fazer algumas requisi√ß√µes para gerar m√©tricas
        for _ in range(3):
            requests.get(f"{self.base_url}/health")
        
        # Aguardar scraping
        time.sleep(20)
        
        # Verificar se m√©tricas est√£o no Prometheus
        query = "http_requests_total"
        response = requests.get(
            f"{self.prometheus_url}/api/v1/query",
            params={"query": query}
        )
        
        if response.status_code != 200:
            return False
        
        data = response.json()
        return data.get("status") == "success" and len(data["data"]["result"]) > 0
    
    def validate_metric_cardinality(self) -> bool:
        """Valida cardinalidade das m√©tricas"""
        response = requests.get(f"{self.prometheus_url}/api/v1/label/__name__/values")
        
        if response.status_code != 200:
            return False
        
        metrics = response.json()["data"]
        
        # Verificar se n√£o h√° muitas m√©tricas (indicador de alta cardinalidade)
        return len(metrics) < 1000
    
    def validate_trace_sampling(self) -> bool:
        """Valida se amostragem de traces est√° funcionando"""
        # Note: Implementa√ß√£o espec√≠fica dependeria do setup
        return True
    
    def validate_grafana_dashboards(self) -> bool:
        """Valida se dashboards do Grafana est√£o funcionando"""
        try:
            # Verificar se Grafana est√° acess√≠vel
            response = requests.get(f"{self.grafana_url}/api/health")
            return response.status_code == 200
        except:
            return False

# Script de valida√ß√£o
def main():
    validator = ObservabilityValidator(
        base_url="http://localhost:8000",
        prometheus_url="http://localhost:9090",
        grafana_url="http://localhost:3000"
    )
    
    print("üîç Validando observabilidade...")
    print("=" * 40)
    
    results = validator.validate_all()
    
    print("\nüìä Resumo:")
    print("=" * 40)
    
    passed = sum(results.values())
    total = len(results)
    percentage = (passed / total) * 100
    
    print(f"Testes passados: {passed}/{total} ({percentage:.0f}%)")
    
    if percentage >= 80:
        print("üéâ Observabilidade validada com sucesso!")
    else:
        print("‚ö†Ô∏è  Observabilidade precisa de ajustes")
        
        failed_tests = [name for name, result in results.items() if not result]
        print(f"Testes falharam: {', '.join(failed_tests)}")

if __name__ == "__main__":
    main()
```

---

## üîß Automa√ß√£o de Testes

### ‚úÖ **CI/CD Pipeline**

```yaml
# .github/workflows/observability-tests.yml
name: Observability Tests

on:
  pull_request:
    branches: [ main, develop ]
  push:
    branches: [ main ]

jobs:
  observability-tests:
    runs-on: ubuntu-latest
    
    services:
      prometheus:
        image: prom/prometheus:latest
        ports:
          - 9090:9090
        options: >-
          --health-cmd "wget --no-verbose --tries=1 --spider http://localhost:9090/-/healthy || exit 1"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      grafana:
        image: grafana/grafana:latest
        ports:
          - 3000:3000
        env:
          GF_SECURITY_ADMIN_PASSWORD: admin
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: Start application
      run: |
        uvicorn main:app --host 0.0.0.0 --port 8000 &
        sleep 10
    
    - name: Run unit tests
      run: |
        pytest tests/unit/ -v --cov=solview
    
    - name: Run integration tests
      run: |
        pytest tests/integration/ -v
    
    - name: Validate observability
      run: |
        python tests/validation/observability_checklist.py
    
    - name: Run load tests
      run: |
        python tests/load/basic_load_test.py
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
```

### ‚úÖ **Makefile para Testes**

```makefile
# Makefile
.PHONY: test test-unit test-integration test-load test-all validate

# Configura√ß√£o
PYTHON = python3
PIP = pip3
PYTEST = pytest

# Instala√ß√£o
install:
	$(PIP) install -r requirements.txt
	$(PIP) install -r requirements-test.txt

# Testes unit√°rios
test-unit:
	$(PYTEST) tests/unit/ -v --cov=solview --cov-report=html

# Testes de integra√ß√£o
test-integration:
	$(PYTEST) tests/integration/ -v

# Testes de carga
test-load:
	$(PYTHON) tests/load/basic_load_test.py
	$(PYTHON) tests/load/stress_test.py

# Valida√ß√£o de observabilidade
validate:
	$(PYTHON) tests/validation/observability_checklist.py

# Executar todos os testes
test-all: test-unit test-integration test-load validate

# Setup para desenvolvimento
dev-setup:
	docker-compose up -d
	sleep 30
	uvicorn main:app --reload &

# Limpeza
clean:
	docker-compose down -v
	rm -rf htmlcov/
	rm -rf .pytest_cache/
	find . -type d -name __pycache__ -delete

# Teste completo com setup
test-full: dev-setup test-all clean
```

---

## üìà M√©tricas de Qualidade

### ‚úÖ **KPIs de Teste**

```python
# tests/metrics/test_quality_metrics.py
def calculate_observability_score(results: dict) -> float:
    """Calcula score de qualidade da observabilidade"""
    
    weights = {
        "metrics_coverage": 0.25,    # 25% - Cobertura de m√©tricas
        "trace_coverage": 0.25,      # 25% - Cobertura de traces  
        "log_structure": 0.20,       # 20% - Qualidade dos logs
        "correlation": 0.15,         # 15% - Correla√ß√£o funcional
        "performance": 0.15          # 15% - Impacto de performance
    }
    
    score = 0
    for metric, weight in weights.items():
        score += results.get(metric, 0) * weight
    
    return score

def generate_quality_report():
    """Gera relat√≥rio de qualidade"""
    
    results = {
        "metrics_coverage": 0.95,    # 95% dos endpoints t√™m m√©tricas
        "trace_coverage": 0.90,      # 90% das opera√ß√µes trackeadas
        "log_structure": 0.85,       # 85% dos logs estruturados
        "correlation": 0.88,         # 88% das correla√ß√µes funcionais
        "performance": 0.92          # 92% - baixo overhead
    }
    
    score = calculate_observability_score(results)
    
    print("üìä Relat√≥rio de Qualidade da Observabilidade")
    print("=" * 50)
    print(f"Score Geral: {score:.2f}/1.00 ({score*100:.0f}%)")
    print()
    
    for metric, value in results.items():
        status = "‚úÖ" if value >= 0.8 else "‚ö†Ô∏è" if value >= 0.6 else "‚ùå"
        print(f"{status} {metric.replace('_', ' ').title()}: {value:.1%}")
    
    if score >= 0.9:
        print("\nüéâ Excelente qualidade de observabilidade!")
    elif score >= 0.8:
        print("\nüëç Boa qualidade de observabilidade")
    else:
        print("\n‚ö†Ô∏è Observabilidade precisa de melhorias")
```

---

<div align="center">

**üß™ Teste com confian√ßa, observe com precis√£o**

[üè† Home](../README.md) | [üìö Docs](README.md) | [üìã Instrumenta√ß√£o](instrumentation-guide.md) | [üìä Best Practices](best-practices.md)

</div>
